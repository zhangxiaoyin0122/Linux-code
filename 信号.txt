信号:是进程之间事件异步通知的一种方式,是一个软件中断,通知进程发生了某个书剑,打断进程当前的操作,去处理这个事件.

1~31:非可靠/非实时信号(信号可能会出现丢失)
34~64:可靠信号/实时信号(信号不会丢失)
信号的生命周期: 信号产生 -> 信号在进程中注册 -> 在进程中注销 -> 处理信号

产生信号:
硬件产生: ctrl+c(中断) ctrl+z(停止) ctrl+\(退出)
软件产生:
	kill 命令
	int kill(pid_t pid,int signum); 给指定进程发送指定的信号
	int raise(int signum);   给进程自身发送指定的信号
	void abort(); 给自身进程发送SIGABRT信号
	int alarm(int sec); 定时器(sec秒后给自身进程发送SIGALRM信号)

执行信号的处理动作称为信号递达,信号从产生到递达之间的状态称为信号未决.
信号的注册:
	进程pcb中有个未决信号集合的表(位图),进程通过这张表中的数据能够获知自己收到了哪个
	信号.信号在进程中注册,就是修改位图中的信息,将对应信号的位置置为1.(位图只能表示有没有收到,但是无法表示收到多少个)
	在pcb中还有一个sigqueue双向链表,链表中有多少个相同信号信息节点就表示这个信号注册了多少次.

	非可靠信号的注册:如果信号已经注册(还没有被处理),则什么都不做,否则注册.
	可靠信号的注册:不管信号是否已经注册,都会注册一次(sigqueue双向队列添加一个节点)
	非可靠信号与可靠信号: 可靠信号在链表中有可能有多个节点,但是非可靠信号最多只有一个.

信号的销毁:
	简而言之就是消除信号在pcb中的痕迹,即删除一个信号的sigqueue节点,没有了相同节点,则位图置0.
信号的处理(递达):
	信号的处理就是调用信号处理函数执行这个函数.

信号的处理方式:
	默认处理方式:系统中定义好的,没有特殊指定时采用的处理方式
	忽略处理方式:针对这个事件,忽略处理方式就是什么都不做(有些信号不同)
	自定义处理方式:程序员自己定义一个信号处理函数,作为指定事件的处理函数.

#include <signal.h> //头文件

typedef void(*sighandler_t)(int);  //定义函数指针

sighandler_t signal(int signum,sighandler_t handler);


信号的捕捉流程:

阻塞信号:
概念:进程在收到信号后,暂时不去处理,直到解除阻塞之后再去处理.
在pcb中同样有一个阻塞信号集合的位图,被添加到这个位图中的信号就表示要阻塞.
阻塞信号:就是将这个信号添加到阻塞集合中(做标记)
解除阻塞集合:就是将这个信号从阻塞集合中移除(解除标记)

int sigprocmask(int how,const sigset_t* set,sigset_t* oldset);
how:表示对阻塞集合的操作 
	SIG_BLOCK:将set集合中的信号添加到阻塞信号中,block|=set
	SIG_UNBLOCK:将set集合中的信号从阻塞集合中移除,block&=~set
	SIG_SETMASK:直接将阻塞集合的值修改为set block = set

函数的重入:
	





